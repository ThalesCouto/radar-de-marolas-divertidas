<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Análise de Vento - Itacoatiara e Itaipu</title>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;600;700&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <style>
        body {
            font-family: 'Poppins', sans-serif;
            background-color: #0077b6; /* Azul do Mar */
            color: #ffffff;
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 20px;
        }

        .header-container {
            background-color: rgba(0, 0, 0, 0.4);
            padding: 20px;
            border-radius: 15px;
            margin-bottom: 30px;
            width: 90%;
            max-width: 1200px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            text-align: center;
        }

        .date-selector label {
            font-size: 1.1em;
            margin-right: 10px;
        }

        .date-selector input[type="date"] {
            padding: 8px;
            border-radius: 5px;
            border: none;
            font-family: inherit;
            font-size: 1em;
        }
        
        .main-content {
            display: flex;
            gap: 30px;
            width: 90%;
            max-width: 1200px;
            flex-wrap: wrap; /* Permite quebrar linha em telas menores */
            justify-content: center;
        }

        .beach-card {
            background-color: rgba(0, 0, 0, 0.4);
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            flex: 1; /* Distribui o espaço entre os cards */
            min-width: 450px;
            margin-bottom: 20px;
        }

        h2 {
            font-size: 1.8em;
            margin-bottom: 10px;
            border-bottom: 2px solid #ffba08;
            padding-bottom: 5px;
            text-align: center;
        }

        .card-subtitle {
            font-size: 0.9em;
            font-weight: 300;
            margin-top: 0;
            margin-bottom: 20px;
            text-align: center;
        }

        /* Estilo para a Nota de Qualidade Atual */
        .current-data {
            display: flex;
            justify-content: space-around;
            align-items: center;
            margin: 20px 0;
        }
        
        .nota-box {
            text-align: center;
            padding: 10px 0;
        }

        .nota-score {
            font-size: 3em;
            font-weight: 700;
            color: #48c9b0; /* Verde/Ciano */
            line-height: 1;
        }

        .nota-label {
            font-size: 0.9em;
            opacity: 0.8;
            margin-top: 5px;
        }

        /* Estilo das Setas */
        .setas-container {
            display: flex;
            justify-content: center;
            gap: 30px;
            margin-bottom: 20px;
        }

        .seta-item {
            text-align: center;
        }

        .icone-seta {
            font-size: 3em;
            display: block;
            margin: 5px auto;
            line-height: 1;
        }

        .seta-atual {
            color: #ffba08; /* Amarelo */
            transition: transform 0.5s ease-out;
        }

        .seta-desejada {
            color: #48c9b0; /* Verde/Ciano */
        }
        
        /* Gráfico */
        .chart-container {
            margin-top: 30px;
            padding: 10px;
            background-color: rgba(255, 255, 255, 0.9);
            border-radius: 10px;
        }

        .loading, .error {
            text-align: center;
            font-size: 1.2em;
            margin-top: 30px;
        }
    </style>
</head>
<body>

<div class="header-container">
    <h1>Previsão do Vento para o Surf</h1>
    <div class="date-selector">
        <label for="date-input">Selecione o Dia:</label>
        <input type="date" id="date-input">
    </div>
</div>

<div class="main-content">
    
    <div class="beach-card" id="itacoatiara-card">
        <h2>Praia de Itacoatiara</h2>
        <div class="card-subtitle" id="itacoatiara-current-subtitle"></div>
        
        <div class="loading" id="itacoatiara-status">Buscando dados...</div>
        
        <div class="chart-container">
            <canvas id="itacoatiara-chart"></canvas>
        </div>
    </div>

    <div class="beach-card" id="itaipu-card">
        <h2>Canal de Itaipu</h2>
        <div class="card-subtitle" id="itaipu-current-subtitle"></div>
        
        <div class="loading" id="itaipu-status">Buscando dados...</div>
        
        <div class="chart-container">
            <canvas id="itaipu-chart"></canvas>
        </div>
    </div>

</div>

<script>
    const API_URL = "https://api.open-meteo.com/v1/forecast";
    
    // Configuração das Praias
    const beaches = {
        itacoatiara: {
            name: "Praia de Itacoatiara",
            lat: -22.97, 
            lon: -43.04,
            desiredDeg: 10, // Nordeste (NE)
            chartInstance: null
        },
        itaipu: {
            name: "Canal de Itaipu",
            lat: -22.95, // Próximo ao Canal
            lon: -43.06,
            desiredDeg: 56, // Ideal para Kitesurf no Canal
            chartInstance: null
        }
    };

    const dateInput = document.getElementById('date-input');

    // Inicializa o seletor de data para o dia atual e o máximo para 7 dias
    function initializeDateInput() {
        const today = new Date();
        const maxDate = new Date();
        maxDate.setDate(today.getDate() + 6); // Previsão de até 7 dias (hoje + 6)

        const formatDate = (date) => {
            const y = date.getFullYear();
            const m = String(date.getMonth() + 1).padStart(2, '0');
            const d = String(date.getDate()).padStart(2, '0');
            return `${y}-${m}-${d}`;
        };

        const todayFormatted = formatDate(today);
        const maxFormatted = formatDate(maxDate);

        dateInput.value = todayFormatted;
        dateInput.min = todayFormatted;
        dateInput.max = maxFormatted;

        dateInput.addEventListener('change', fetchAllData);
    }

    /**
     * Converte graus de direção do vento (0-360) para pontos cardeais.
     */
    function degToCardinal(deg) {
        if (deg > 337.5 || deg <= 22.5) return "N";
        if (deg > 22.5 && deg <= 67.5) return "NE";
        if (deg > 67.5 && deg <= 112.5) return "L";
        if (deg > 112.5 && deg <= 157.5) return "SE";
        if (deg > 157.5 && deg <= 202.5) return "S";
        if (deg > 202.5 && deg <= 247.5) return "SO";
        if (deg > 247.5 && deg <= 292.5) return "O";
        if (deg > 292.5 && deg <= 337.5) return "NO";
        return "Indef.";
    }

    /**
     * Calcula uma nota de 0 a 10 com base na proximidade da direção do vento.
     */
    function calculateWindScore(currentDeg, desiredDeg) {
        let diff = Math.abs(currentDeg - desiredDeg);
        if (diff > 180) {
            diff = 360 - diff;
        }
        const score = 10 - (diff / 180) * 10;
        return parseFloat(score.toFixed(1));
    }

    /**
     * Renderiza o card e o gráfico de uma praia específica.
     */
    function renderBeachData(beachKey, hourlyData) {
        const beach = beaches[beachKey];
        const cardElement = document.getElementById(`${beachKey}-card`);
        const statusElement = document.getElementById(`${beachKey}-status`);
        const subtitleElement = document.getElementById(`${beachKey}-current-subtitle`);
        const now = new Date();
        const selectedDate = dateInput.value;
        const todayFormatted = new Date().toISOString().slice(0, 10);
        
        // 1. Encontra o dado mais atual
        let currentWind = null;
        let currentIndex = -1;
        
        // Se a data selecionada for hoje, busca o dado atual/mais próximo
        if (selectedDate === todayFormatted) {
            const currentHour = now.getHours();
            currentIndex = hourlyData.time.findIndex(timeStr => {
                const hour = parseInt(timeStr.substring(11, 13));
                return hour >= currentHour;
            });
            // Se não encontrou, pega o último do dia
            if (currentIndex === -1) currentIndex = hourlyData.time.length - 1;
            
            currentWind = {
                time: hourlyData.time[currentIndex],
                speed: hourlyData.wind_speed_10m[currentIndex],
                direction: hourlyData.wind_direction_10m[currentIndex]
            };
            
            // Atualiza o subtítulo para mostrar a hora atualizada
            const currentHourStr = currentWind.time.substring(11, 16);
            subtitleElement.textContent = `Previsão atualizada para ${currentHourStr}h`;
            
        } else {
            // Se for previsão futura, pega a primeira hora do dia
            currentIndex = 0;
            currentWind = {
                time: hourlyData.time[currentIndex],
                speed: hourlyData.wind_speed_10m[currentIndex],
                direction: hourlyData.wind_direction_10m[currentIndex]
            };
            subtitleElement.textContent = `Previsão para ${selectedDate.split('-').reverse().join('/')}`;
        }
        
        // Se não houver dados, exibe erro
        if (!currentWind) {
            statusElement.innerHTML = `<p class="error">Dados de vento indisponíveis para a data.</p>`;
            return;
        }

        const currentDirectionCardinal = degToCardinal(currentWind.direction);
        const currentScore = calculateWindScore(currentWind.direction, beach.desiredDeg);
        const desiredCardinal = degToCardinal(beach.desiredDeg);

        // 2. Renderiza o HTML (Atual e Setas)
        const htmlContent = `
            <div class="current-data">
                <div class="nota-box">
                    <div class="nota-score">${currentScore}</div>
                    <div class="nota-label">Nota (0-10)</div>
                </div>
                <div class="nota-box">
                    <div class="nota-score">${currentDirectionCardinal}</div>
                    <div class="nota-label">Vento Atual</div>
                </div>
                <div class="nota-box">
                    <div class="nota-score">${currentWind.speed.toFixed(0)} km/h</div>
                    <div class="nota-label">Velocidade</div>
                </div>
            </div>

            <div class="setas-container">
                <div class="seta-item">
                    <span class="icone-seta seta-atual" style="transform: rotate(${currentWind.direction + 180}deg);">
                        &#x27A4;
                    </span>
                    <div class="seta-label">Atual (${currentWind.direction}°)</div>
                </div>
                
                <div class="seta-item">
                    <span class="icone-seta seta-desejada" style="transform: rotate(${beach.desiredDeg + 180}deg);">
                        &#x27A4;
                    </span>
                    <div class="seta-label">Ideal (${desiredCardinal}, ${beach.desiredDeg}°)</div>
                </div>
            </div>
        `;
        
        // Remove o loading e injeta o conteúdo
        statusElement.innerHTML = htmlContent;

        // 3. Renderiza o Gráfico
        const hours = hourlyData.time.map(t => t.substring(11, 16)); // Ex: "10:00"
        const scores = hourlyData.wind_direction_10m.map(deg => calculateWindScore(deg, beach.desiredDeg));
        const directions = hourlyData.wind_direction_10m.map(deg => degToCardinal(deg));
        const speeds = hourlyData.wind_speed_10m.map(s => s.toFixed(0));

        updateChart(beachKey, hours, scores, directions, speeds);
    }

    /**
     * Cria/Atualiza o gráfico de linha.
     */
    function updateChart(beachKey, labels, scores, directions, speeds) {
        const ctx = document.getElementById(`${beachKey}-chart`).getContext('2d');
        const beach = beaches[beachKey];

        // Destrói a instância anterior se existir
        if (beach.chartInstance) {
            beach.chartInstance.destroy();
        }

        beach.chartInstance = new Chart(ctx, {
            type: 'line',
            data: {
                labels: labels,
                datasets: [{
                    label: 'Nota de Qualidade (0-10)',
                    data: scores,
                    borderColor: '#48c9b0', // Cor da nota (Verde/Ciano)
                    backgroundColor: 'rgba(72, 201, 176, 0.2)',
                    fill: true,
                    tension: 0.4,
                    yAxisID: 'y'
                }]
            },
            options: {
                responsive: true,
                plugins: {
                    title: {
                        display: true,
                        text: 'Nota de Vento e Direção Horária',
                        color: '#333'
                    },
                    legend: {
                        display: false
                    },
                    tooltip: {
                        callbacks: {
                            afterLabel: function(context) {
                                const index = context.dataIndex;
                                return [
                                    `Direção: ${directions[index]} (${beach.desiredDeg} ideal)`,
                                    `Velocidade: ${speeds[index]} km/h`
                                ];
                            }
                        }
                    }
                },
                scales: {
                    x: {
                        title: {
                            display: true,
                            text: 'Hora do Dia',
                            color: '#333'
                        },
                        grid: {
                            display: false
                        },
                        ticks: {
                            color: '#333'
                        }
                    },
                    y: {
                        title: {
                            display: true,
                            text: 'Nota de Vento',
                            color: '#333'
                        },
                        min: 0,
                        max: 10,
                        ticks: {
                            color: '#333'
                        }
                    }
                }
            }
        });
    }

    /**
     * Faz a requisição da API para ambas as praias.
     */
    async function fetchAllData() {
        const selectedDate = dateInput.value;
        if (!selectedDate) return;

        // Converte a data selecionada para o formato "YYYY-MM-DD" necessário para a API
        const startDate = selectedDate;
        const endDate = selectedDate;

        for (const key in beaches) {
            const beach = beaches[key];
            const statusElement = document.getElementById(`${key}-status`);
            statusElement.innerHTML = `<p class="loading">Buscando previsão para ${startDate}...</p>`;

            try {
                const params = new URLSearchParams({
                    latitude: beach.lat,
                    longitude: beach.lon,
                    hourly: 'wind_speed_10m,wind_direction_10m', // Dados horários
                    start_date: startDate,
                    end_date: endDate,
                    timezone: 'America/Sao_Paulo'
                });

                const response = await fetch(`${API_URL}?${params.toString()}`);
                
                if (!response.ok) {
                    throw new Error(`Erro HTTP: ${response.status}`);
                }

                const data = await response.json();
                
                if (data.hourly && data.hourly.time.length > 0) {
                    renderBeachData(key, data.hourly);
                } else {
                    throw new Error("Dados horários não encontrados.");
                }

            } catch (error) {
                console.error(`Erro ao buscar dados para ${beach.name}:`, error);
                statusElement.innerHTML = `<p class="error">Erro ao carregar os dados do vento para ${beach.name}.</p>`;
            }
        }
    }

    // Inicia o seletor de data e carrega os dados iniciais
    initializeDateInput();
    fetchAllData();
    
</script>

</body>
</html>
